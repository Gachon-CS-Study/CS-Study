![](https://velog.velcdn.com/images/ehs208/post/5d2559f1-8d89-442b-85ee-069330835d3c/image.png)

## Stack vs Queue

### Stack

Stack은 LIFO(Last In First Out) 구조로 되어 있으며, 쉽게 해석하면 "후입 선출" 이다.
즉, **마지막(최근)에 넣은 것을 먼저 뺀다**는 말이다.

### Queue

Queue는 FIFO(First In First Out) 구조로, Stack과 반대로 "선입 선출" 이다.
즉, **먼저 넣은 것(오래된 것)을 먼저 뺀다**는 말이다.

## Stack

자바에서는 스택을 기본 자료 구조로 제공하기 때문에, 별도의 라이브러리나 모듈을 설치할 필요가 없다.

### Stack의 메소드

| 메소드                   | 설명                                                                                                                      |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------- |
| boolean empty()          | Stack이 비어있는지 알려준다.                                                                                              |
| Object peek()            | Stack의 맨 위에 저장된 객체를 반환.pop()과는 달리 Stack에서 객체를 꺼내지는 않는다. (비었다면 EmptyStackException발생)    |
| Object pop()             | Stack의 맨 위에 저장된 객체를 꺼낸다.( 비었다면 EmptyStackException발생 )                                                 |
| Object push(Object item) | Stack에 객체(item)을 저장한다.                                                                                            |
| int search(Object o)     | Stack에 주어진 객체(o)를 찾아서 그 위치를 반환한다.못찾으면 -1을 반환한다.( 배열과 달리 위치는 0이 아닌 1부터 시작한다. ) |

### Stack 사용 예

```java
Stack<Integer> stack = new Stack<>(); //Integer형 스택 선언

stack.push(1);
stack.push(2);
stack.push(3);
stack.push(4);

stack.peek(); // 4

stack.pop();
stack.pop();
stack.pop();
stack.pop();

// 마지막부터 나오게 된다 4->3->2->1

stack.empty(); // true 반환

```

## Queue

데이터의 추가/삭제가 쉬운 LinkedList로 구현하는 것이 적합하다.

### Queue의 메소드

| 메소드                  | 설명                                                                               |
| ----------------------- | ---------------------------------------------------------------------------------- |
| boolean add(Object o)   | 지정된 객체를 Queue에 추가한다. (저장공간이 부족하면 `IllegalStateException` 발생) |
| Object remove()         | Queue에서 객체를 꺼내 반환한다. (비었으면 NoSuchElementException 발생)             |
| Object element()        | 삭제없이 요소를 읽어온다. (Queue가 비었을 때 NoSuchElementException 발생)          |
| boolean offer(Object o) | Queue에 객체를 저장한다.                                                           |
| Object poll()           | Queue에서 객체를 꺼내서 반환한다. (저장된 건 삭제된다. 비어있으면 `null`)          |
| Object peek()           | 삭제없이 요소를 읽어온다. (비어있으면 `null`)                                      |

### Queue 사용 예

```java
Queue<Integer> queue = new LinkedList<>(); //Integer형 queue 선언

queue.offer(1);     // queue에 값 1 추가
queue.offer(2);     // queue에 값 2 추가
queue.offer(3);     // queue에 값 3 추가
queue.offer(4);     // queue에 값 4 추가
queue.add(5);

queue.peek(); // 1
queue.element(); // 1

queue.poll();
queue.poll();
queue.poll();
queue.poll();
queue.remove();

// 제일 첫 번째 있는 데이터부터 차례대로 나오게 된다. 1, 2, 3, 4, 5
```

Queue 경우에는 비슷하게 작동하는 메소드들이 존재한다.

| 카테고리 | 예외 발생 | 값 출력 |
| -------- | --------- | ------- |
| 추가     | add()     | offer() |
| 삭제     | remove()  | poll()  |
| 읽기     | element() | peek()  |

각 상황에 맞는 메소드를 사용하면 된다.

## PriorityQueue

Queue인터페이스의 구현체 중의 하나로, 저장한 순서에 관계없이 우선순위(priority)가 높은 것부터 꺼낸다.

## Deque

Queue의 변형으로, 양쪽 끝에 추가/삭제가 가능하다. (스택 + 큐)
구현체로는 ArrayDeque와 LinkedList 등이 있다.
