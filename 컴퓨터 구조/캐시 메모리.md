<h1>소주제:[캐시 메모리]</h1>
<hr>

<h2>[캐시메모리의 전반적인 설명]</h2>

빠른 장치와 느린 장치간의 속도차이로 인해 병목현상이 발생을 한다.

![하드디스크와 램](https://github.com/user-attachments/assets/99305d79-f9bb-4dda-ae18-709d5b7fc7cd)

컴퓨터에 저장공간은 하드디스크와 RAM 메모리 보통 이 2가지로 나눈다.

두 장치의 속도 차이 : RAM > 하드 디스크

그래서 결국 CPU는 RAM 을 주로 이용하여 작업을 합니다.

<h3>cpu와 ram의 속도차이로 인한 병목 현상 발생</h3>

![병목 현상](https://github.com/user-attachments/assets/c3b04eec-46b7-419f-a924-a43951b540f7)

램 메모리가 아무리 하드디스크 보다 빠르다 할지라도.

CPU의 동작속도를 따라가지는 못한다.

CPU가 프로그래며가 설계해 놓은 엄청나게 복잡하고 많은 명령어를 하나씩! 시행을 해야 하는데,

여기에 메모리를 공급해주는 RAM 이 이 명령어 처리 속도를 따라가지 못한다.

여기서 발생하는 것이 병목현상이다.

이떄 발생하는 병목현상을 완화하기 위해 존재하는 것이 캐시 메모리이다.

캐시 메모리의 기본 사용형식은 다음과 같다.

CPU에서 주 기억장치에 저장된 데이터를 불러오는 작업에서, 자주 사용하는 데이터는 캐시 메모리에 저장을 한다.
차후, 해당 데이터를 다시 요청을 할때는, 주기억장치가 아닌 캐시 메모리에서 가져오는 식으로 속도를 향상시킨다.

![l1,l2,l3의 비교](https://github.com/user-attachments/assets/6aa785f8-83d7-4db0-8168-4c8a6f122cf6)


CPU에는 이런 캐시 메모리가 2~3개가 사용된다.
이들은 각각 L1, L2, L3 캐시 메모리라고 부른다.

속도와 크기에 따라 분류한 것으로, 일반적으로 L1 캐시부터 먼저 사용된다. 
CPU에서 가장 빠르게 L1으로 접근하고, 여기서 데이터를 찾지 못하면 L2로 간다.

코어가 4개인 CPU에서의 구조도

![l1,l2,l3](https://github.com/user-attachments/assets/6c1d28d8-8731-4b2c-b17b-7d9f1ba0fd70)


L1 : CPU 내부에 존재

L2 : CPU와 RAM 사이에 존재

L3 : 보통 메인보드에 존재


<h2>[캐시 히트, 캐시 미스]</h2>

![캐시 히트 캐시미스](https://github.com/user-attachments/assets/33f465d6-0606-48ae-a691-c0cce8f50417)

Cache Hit: CPU가 요청한 데이터가 캐시에 있는 경우-> 한국말로 캐시 적중이라고도 불린다.

 이 적중율이 높을수록 메모리까지 접근할 필요가 없으므로 처리 속도는 더 빨라지는 것이다.

Cache Miss: CPU가 요청한 데이터가 캐시에 없어서 DRAM에서 가져오는 경우

<h2>[캐시 메모리의 작동 원리-시간 지역성과 공간 지역성]</h2>

캐시 메모리의 시간 지역성(Temporal Locality)과 공간 지역성(Spatial Locality)은 프로그램이 메모리에 접근할 때 나타나는 일반적인 패턴을 설명하는 개념입니다.

<h3>1. 시간 지역성 (Temporal Locality)</h3>

![for문](https://github.com/user-attachments/assets/22b37630-e1c0-4e41-acae-df78cde783d6)


정의: 시간 지역성은 한 번 참조된 메모리 주소나 데이터가 가까운 시간 내에 다시 참조될 가능성이 높은 특성을 의미합니다.

프로그램은 특정 변수나 데이터에 여러 번 접근하는 경우가 많습니다. 

예를 들어, 반복문에서 같은 변수나 데이터에 반복적으로 접근할 수 있습니다.

캐시는 이러한 접근 패턴을 활용하여, 최근에 사용된 데이터를 캐시에 저장해 두면 이후에 다시 그 데이터에 접근할 때 빠르게 제공할 수 있습니다.

최근에 사용된 데이터가 다시 사용될 가능성이 높으므로, 캐시는 오래 사용되지 않은 데이터를 제거하는 방식으로 최적화할 수 있습니다

->sum 변수에 대한 시간 지역성이 존재한다.

<h3>2. 공간 지역성 (Spatial Locality)</h3>

![배열](https://github.com/user-attachments/assets/01c3881c-f9a7-42fe-a3d1-59239d201ea3)

정의: 공간 지역성은 한 번 참조된 메모리 주소와 인접한 주소들이 가까운 시간 내에 참조될 가능성이 높은 특성을 의미합니다.

배열과 같이 연속된 메모리 공간에 데이터를 저장하는 경우가 많습니다. 

프로그램은 종종 이러한 연속된 데이터에 순차적으로 접근합니다.

캐시는 연속된 메모리 블록을 한꺼번에 로드하여 공간 지역성을 활용합니다. 

이렇게 하면 연속된 데이터 접근이 발생할 때 캐시 히트(cache hit) 확률을 높일 수 있습니다.

프리패칭(prefetching) 기술: CPU는 데이터나 명령어를 캐시에 로드할 때 인접한 메모리 블록을 미리 로드해 둘 수 있다.

<h2>[캐시 미스의 3종류]</h2>

<h3>Cold miss</h3>
해당 메모리 주소를 처음 불러서 나는 미스

<h3>Conflict miss</h3>
주소 할당 문제이다
.
캐시 메모리에 A,B 두개의 메모리를 저장해야 하는 상황에서,둘다 같은 메모리에 저장해서 나는 미스

<h3>Capacity miss</h3>
공간 할당 문제이다.

캐시 메모리 공간이 부족해서 나는 미스이다.

-> 그럼 이 3번째 캐시 미스의 공간 할당 문제를 단순히 캐시의 크기를 키우면 되는 문제 아닌가?

->캐시 점근 속도 저하 + 파워를 많이 먹는 단점이 존재


<h2>[구조 및 작동 방식]</h2>
<h3>1. Direct Mapped Cache</h3>

![Direct Mapped Cache](https://github.com/user-attachments/assets/abfabb05-9ab4-4550-b864-219ba49f7000)


가장 기본적인 구조로, DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 다대일 방식

메모리 공간이 32개(00000~11111)이고, 캐시 메모리 공간은 8개(000~111)인 상황

ex)여기서 메모리 000001, 010001, 100001,110001은 001에 저장

이때 001이 '인덱스 필드', 인덱스 제외한 앞의 나머지(00, 01, 10, 11)를 '태그 필드'라고 한다.


-> 장점 : 간단하고 빠르다.

->단점: Conflict miss 발생

<h3>2.Fully Associative Cache</h3>
비어있는 캐시 메모리가 있으면, 마음대로 주소를 저장하는 방식이다.

이떄 마음대로 주소를 저장하기에 조건이나 규칙이 없다.

그래서 한번 찾을때는, 모든 블럭을 한번에 찾아야 원하는 데이터가 있는지 검색을 해야 한다.

->장점:저장할 때 매우 간단하다

->단점: 찾을 때 찾기가 매우 어렵다. 

<h3>3.Set Associative Cache</h3>
위 두개의 구조를 합친 방식이다.

특정 행을 지정하고, 그 행안의 어떤 열이든 비어있을 때 저장하는 방식이다. 

Direct에 비해 검색 속도는 느리지만, 저장이 빠르고 Fully에 비해 저장이 느린 대신 검색이 빠른 중간형이다.

<br>
<br>

<h3>1.캐시 메모리가 컴퓨터 시스템에서 중요한 이유를 설명하시오. 특히, CPU와 RAM 간의 속도 차이로 인해 발생하는 문제를 해결하는 데 캐시 메모리가 어떻게 도움이 되는지 설명하시오</h3>

<h3>2.다음 코드에서 시간 지역성과 공간 지역성의 예를 찾고 설명하시오.</h3>

for (int i = 0; i < 1000; i++) {

   sum += array[i];
   
}

<h3>3.Direct Mapped Cache, Fully Associative Cache, Set Associative Cache의 구조적 차이를 설명하시오</h3>

