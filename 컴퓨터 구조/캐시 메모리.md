<h1>소주제:[캐시 메모리]</h1>
<hr>

<h2>[캐시메모리의 전반적인 설명]</h2>

빠른 장치와 느린 장치간의 속도차이로 인해 병목현상이 발생을 한다.

이떄 발생하는 병목현상을 완화하기 위해 존재하는 것이 캐시 메모리이다.

캐시 메모리의 기본 사용형식은 다음과 같다.

CPU에서 주 기억장치에 저장된 데이터를 불러오는 작업에서, 자주 사용하는 데이터는 캐시 메모리에 저장을 한다.
차후, 해당 데이터를 다시 요청을 할때는, 주기억장치가 아닌 캐시 메모리에서 가져오는 식으로 속도를 향상시킨다.

CPU에는 이런 캐시 메모리가 2~3개가 사용된다.
이들은 각각 L1, L2, L3 캐시 메모리라고 부른다.

속도와 크기에 따라 분류한 것으로, 일반적으로 L1 캐시부터 먼저 사용된다. 
CPU에서 가장 빠르게 L1으로 접근하고, 여기서 데이터를 찾지 못하면 L2로 간다.

L1 : CPU 내부에 존재

L2 : CPU와 RAM 사이에 존재

L3 : 보통 메인보드에 존재


<h2>[캐시 히트, 캐시 미스]</h2>

Cache Hit: CPU가 요청한 데이터가 캐시에 있는 경우

Cache Miss: CPU가 요청한 데이터가 캐시에 없어서 DRAM에서 가져오는 경우

<h2>[캐시 메모리의 작동 원리-시간 지역성과 공간 지역성]</h2>

캐시 메모리의 시간 지역성(Temporal Locality)과 공간 지역성(Spatial Locality)은 프로그램이 메모리에 접근할 때 나타나는 일반적인 패턴을 설명하는 개념입니다.

<h3>1. 시간 지역성 (Temporal Locality)</h3>
정의: 시간 지역성은 한 번 참조된 메모리 주소나 데이터가 가까운 시간 내에 다시 참조될 가능성이 높은 특성을 의미합니다.

프로그램은 특정 변수나 데이터에 여러 번 접근하는 경우가 많습니다. 

예를 들어, 반복문에서 같은 변수나 데이터에 반복적으로 접근할 수 있습니다.

캐시는 이러한 접근 패턴을 활용하여, 최근에 사용된 데이터를 캐시에 저장해 두면 이후에 다시 그 데이터에 접근할 때 빠르게 제공할 수 있습니다.

최근에 사용된 데이터가 다시 사용될 가능성이 높으므로, 캐시는 오래 사용되지 않은 데이터를 제거하는 방식으로 최적화할 수 있습니다

<예시 코드>
for (int i = 0; i < 1000; i++) {
    sum += array[i];
}

->sum 변수에 대한 시간 지역성이 존재한다.

<h3>2. 공간 지역성 (Spatial Locality)</h3>
정의: 공간 지역성은 한 번 참조된 메모리 주소와 인접한 주소들이 가까운 시간 내에 참조될 가능성이 높은 특성을 의미합니다.

배열과 같이 연속된 메모리 공간에 데이터를 저장하는 경우가 많습니다. 

프로그램은 종종 이러한 연속된 데이터에 순차적으로 접근합니다.

캐시는 연속된 메모리 블록을 한꺼번에 로드하여 공간 지역성을 활용합니다. 

이렇게 하면 연속된 데이터 접근이 발생할 때 캐시 히트(cache hit) 확률을 높일 수 있습니다.

프리패칭(prefetching) 기술: CPU는 데이터나 명령어를 캐시에 로드할 때 인접한 메모리 블록을 미리 로드해 둘 수 있다.

<h2>[캐시 미스의 3종류]</h2>

<h3>Cold miss</h3>
해당 메모리 주소를 처음 불러서 나는 미스

<h3>Conflict miss</h3>
주소 할당 문제이다
.
캐시 메모리에 A,B 두개의 메모리를 저장해야 하는 상황에서,둘다 같은 메모리에 저장해서 나는 미스

<h3>Capacity miss</h3>
공간 할당 문제이다.

캐시 메모리 공간이 부족해서 나는 미스이다.

-> 그럼 이 3번째 캐시 미스의 공간 할당 문제를 단순히 캐시의 크기를 키우면 되는 문제 아닌가?

->캐시 점근 속도 저하 + 파워를 많이 먹는 단점이 존재


<h2>[구조 및 작동 방식]</h2>
<h3>1. Direct Mapped Cache</h3>

가장 기본적인 구조로, DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 다대일 방식

메모리 공간이 32개(00000~11111)이고, 캐시 메모리 공간은 8개(000~111)인 상황

ex) 00000, 01000, 10000, 11000인 메모리 주소는 000 캐시 메모리 주소에 맵핑

이때 000이 '인덱스 필드', 인덱스 제외한 앞의 나머지(00, 01, 10, 11)를 '태그 필드'라고 한다.

이처럼 캐시메모리는 인덱스 필드 + 태그 필드 + 데이터 필드로 구성된다.

-> 장점 : 간단하고 빠르다.

->단점: Conflict miss 발생

<h3>2.Fully Associative Cache</h3>
비어있는 캐시 메모리가 있으면, 마음대로 주소를 저장하는 방식이다.

이떄 마음대로 주소를 저장하기에 조건이나 규칙이 없다.

그래서 한번 찾을때는, 모든 블럭을 한번에 찾아야 원하는 데이터가 있는지 검색을 해야 한다.

->장점:저장할 때 매우 간단하다

->단점: 찾을 때 찾기가 매우 어렵다. 

<h3>3.Set Associative Cache</h3>
위 두개의 구조를 합친 방식이다.

특정 행을 지정하고, 그 행안의 어떤 열이든 비어있을 때 저장하는 방식이다. 

Direct에 비해 검색 속도는 느리지만, 저장이 빠르고 Fully에 비해 저장이 느린 대신 검색이 빠른 중간형이다.



