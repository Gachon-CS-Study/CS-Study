# 페이징과 세그먼테이션
## 가상 메모리 시스템

- 물리 메모리(실제 메모리)의 크기와 상관없이 메모리를 이용할 수 있도록 지원하는 기술

### 가상 메모리가 없다면?

- 메모리 크기는 컴퓨터마다 다른데, 운영체제가 물리 메모리의 크기에만 의지하는 경우
    - 2GB 메모리에서 동작하는 프로그램이 1GB 메모리에서는 동작하지 않을 수 있음
- 개발할 때에도 메모리 크기에 맞는 응용 프로그램만 개발해야 함
    - 실제로 메모리 크기를 고려하여 프로그래밍하기 어려움
    

### 가상 메모리의 크기와 주소

- 주소
    - 모든 프로세스는 0번부터 시작하는 연속된 메모리 공간을 가짐
    - 메모리의 어느 위치에 있는지는 상관 없음
- 크기
    - 이론적으로 무한대
    - 실제로는 컴퓨터 시스템이 가진 물리 메모리의 최대 크기로 한정, CPU의 비트에 따라 결정됨
        - 32bit CPU의 경우 32bit로 표현할 수 있는 최댓값인 약 4GB가 됨
        

### 어떻게 메모리를 무한대로 사용할까?

- 여러개의 프로세스를 동시에 실행 할 때 최대 메모리 크기를 넘어가면 SWAP을 하게 됨
- 하드디스크의 일부 공간을 스왑 영역으로 사용함
- 스왑 영역은 하드디스크에 존재하지만 메모리 관리자가 관리하는 영역으로 메모리의 일부, 가상메모리의 구성 요소 중 하나
- 스왑 아웃 : 물리 메모리가 찼을 때 일부 프로세스를 스왑 영역으로 보냄
- 스왑 인 : 몇 개의 프로세스가 작업을 마치면 스왑 영역에 있는 프로세스를 메모리로 가져옴

### 동적 주소 변환

- 물리 메모리와 스왑 영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 메모리의 물리 주소로 변환하는 과정
- 이 과정으로 프로세스가 아무 제약 없이 사용자 데이터를 물리 메모리에 배치할 수 있음
- 처리 해야하는 문제 : 물리 메모리를 나누는 방식, 사용자 프로세스를 배치할 위치, 부족한 물리 메모리 처리 방법

### 매핑 테이블

- 가상 메모리 시스템에서 가상 주소는 실제로 물리 주소나 스왑 영역 중 한 곳에 위치
- 가상 주소와 물리 주소를 일대일로 매핑한 테이블

![매핑테이블.png](운영체제/images/페이징과_세그먼테이션/매핑테이블.png)


### 메모리 분할 방식

- 고정 분할 방식과 가변 분할 방식으로 나뉨
- 고정 분할 방식 : 페이징 기법
- 가변 분할 방식 : 세그먼테이션 기법

## 고정 분할 방식 - 페이징 기법

### 구현

- 물리 주소 공간을 같은 크기로 나누어 사용

![페이징구현.png](운영체제/images/페이징과_세그먼테이션/페이징구현.png)

- 가상 주소의 분할된 각 영역을 페이지라고 부르고 번호를 매겨 관리
- 물리 메모리의 각 영역은 가상 주소의 페이지와 구분하기 위해 프레임이라고 부름
- 페이지와 프레임의 크기는 같음
- 페이지 테이블의 invalid는 해당 페이지가 스왑 영역에 있다는 뜻

### 주소 변환

![페이징주소변환.png](운영체제/images/페이징과_세그먼테이션/페이징주소변환.png)
이해를 위해 가상 주소 공간과 물리 주소 공간을 똑같이 10B로 나누었고 이에 따라 한 페이지/프레임은 10개의 주소를 가짐

- 가상 주소 → 물리 주소
    1. 가상 주소 30번이 어느 페이지에 있는지 찾는다. 30번은 페이지 3의 0번 위치에 있다
    2. 페이지 테이블의 페이지 3으로 가서 해당 페이지가 프레임 1에 있다는 것을 확인한다.
    3. 물리 페모리 프레임 1의 0번 위치에 접근한다. 이 주소가 가상 주소 30번의 물리 주소이다.
- 정형화

$$
VA = <P, D>  \rightarrow FA=<F, D>
$$

VA : 가상 주소, P : 페이지, D : 페이지의 처음 위치에서 해당 주소까지의 거리

FA : 물리 주소, F : 프레임, D : 프레임의 처음 위치에서 해당 주소까지의 거리

![페이징정형화.png](운영체제/images/페이징과_세그먼테이션/페이징정형화.png)

## 가변 분할 방식 - 세그먼테이션 기법

### 구현

- 물리 메모리를 프로세스 크기에 따라 가변적으로 나누어 사용

![세그먼테이션구현.png](운영체제/images/페이징과_세그먼테이션/세그먼테이션구현.png)

- 용어
    - limit : 세그먼트의 크기를 나타냄
    - address : 물리 메모리의 시작 주소를 나타냄
    - I (invalid) : 스왑 영역에 있음을 표시
- 장점 : 메모리를 프로세스 단위로 관리하기 때문에 세그먼테이션 테이블이 작고 단순
- 단점 : 물리 메모리의 외부 단편화로 인해 관리가 복잡함

### 주소 변환

![세그먼테이션주소변환.png](운영체제/images/페이징과_세그먼테이션/세그먼테이션주소변환.png)

프로세스 A는 세그먼트 0, 프로세스 B는 세그먼트 1, 프로세스 C는 세그먼트 2로 분할되어 있음

- 프로세스 A의 32번에 접근
    1. 가상 주소 구하기 : 프로세스 A는 세그먼트 0으로 분할되었으므로 S는 0, D는 32
        
        → VA=<0,32>
        
    2. 세그먼테이션 테이블에서 세그먼트 0의 시작 주소 120을 알아낸 후 D 32를 더하여 물리주소 152번을 구한다.
        1. 이때 메모리 관리자는 거리가 세그먼트의 크기보다 큰지 점검한다.
        2. 크다면 메모리를 벗어나는 것이므로 메모리 오류를 출력하고 해당 프로세스를 강제종료한다. 크지 않다면 물리 주소를 구한다.
    3. 물리주소 152번에 접근하여 원하는 데이터는 읽거나 쓴다.

---

## 질문

1. 가상 메모리의 크기를 무한대로 볼 수 있는 이유는?
2. 페이징 기법의 주소 변환 과정은?
3. 세그먼테이션 기법의 주소 변환 과정은?

## 출처

**쉽게 배우는 운영체제** 조성호 저
