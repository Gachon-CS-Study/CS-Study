# 저장 프로시저

DB 내부에 저장된 일련의 SQL 명령문들을 하나의 함수처럼 실행하기 위한 쿼리의 집합. 즉, DB에 대한 작업을 정리한 절차를 RDBMS(관계형 데이터 베이스 관리 시스템)에 저장한 쿼리의 집합이다. 영구저장모듈이라고도 불린다. 여러 쿼리를 하나의 함수로 묶은 것이다.

실무에서는 프로그램에서 만들어 놓은 SQL문을 저장해 놓고, 필요할 때마다 호출해서 사용하는 방식으로 프로그램을 만든다. 이 것을 가능하게 해주는 것이 `저장 프로시저` 이다.

# 일반 쿼리문 vs 저장 프로시저

## 일반 쿼리문

![](images/저장%20프로시저/sql문.png)

```sql
SELECT name FROM userTbl;
```

### 실행 과정

1. **구문 분석** 단계에서 구문 자체에 오류가 없는지 분석을 한다. 만약 오타가 있으면 여기서 오류가 발생되어 에러메시지를 띄울 것이다.

2. **개체 이름 확인** 단계에서 userTbl 이라는 테이블이 현재 데이터베이스에 있는지 확인을 한다. 만약에 userTbl이 있으면 그안에 name이라는 열이 있는지를 확인할 것이다.

3. **사용권한 확인** 단계에서 userTbl을 현재 접근중인 사용자가 권한이 있는지를 확인한다.

4. **최적화** 단계에서 해당 쿼리문이 가장 좋은 성능을 낼 수 있는 경로를 결정한다.

5. 최적화된 결과를 바탕으로 **컴파일 및 실행 계획 등록** 단계에서 해당 실행계획 결과를 **메모리(캐시)**에 등록한다.

6. 컴파일된 결과를 **실행**한다.

> 💡 만약에 동일한 SQL문을 실행하면 과정들을 생략하고 캐시에서 실행 계획을 가져와 단순하게 동작하게 된다.

## 저장 프로시저

### 저장 프로시저 정의 과정

![alt text](images/저장%20프로시저/저장프로시저1.png)

1. 구문분석 : 구문의 오류 파악
2. 지연된 이름 확인 : 저장 프로시저를 정하는 시점에서 해당 개체(ex. 테이블)가 존재하지 않아도 상관없다. 프로시저 실행 당시에 테이블 존재 여부 확인함(개체이름 확인).
3. 생성권한 확인 : 현재 사용자가 저장 프로시저를 생성할 권한이 있는지 확인
4. 시스템 테이블 등록 : 저장 프로시저의 이름 및 코드가 시스템 테이블에 등록.

### 저장 프로시저 첫 실행 과정

![alt text](images/저장%20프로시저/저장프로시저2.png)

구문분석 단계가 빠지는 것만 빼면 일반적인 쿼리문 수행단계와 동일하다. 저장프로시저 정의 단계의 지연된 이름확인에서 미루어두었던 해당 개체 존재 유무를 개체 이름 확인을 통해 수행한다.

### 이후 저장 프로시저 실행 과정

![alt text](images/저장%20프로시저/저장프로시저3.png)

이후에 두번째 실행 부터는 메모리(캐시)에 있는 것을 그대로 가져와 재사용하게 되어 수행시간을 많이 단축한다.

## 일반 쿼리문과 저장 프로시저의 차이점

```sql
SELECT * FROM userTbl WHERE name ='이승기';
SELECT * FROM userTbl WHERE name ='성시경';
SELECT * FROM userTbl WHERE name ='은지원';
```

해당 쿼리들은 WHERE 조건의 값만 다르다. 그러나 일반 쿼리는 글자 하나라도 다르면 다른 쿼리라 인식하기 때문에 세 쿼리 모두 다 다른 것으로 인식해버린다. 그렇기 때문에 매번 최적화와 컴파일을 다시 수행해야한다.

만약 위의 쿼리들을 `저장 프로시저`로 만든다면

```sql
CREATE PROC select_by_name
	@Name NVARCHAR(3)
AS
	SELECT * FROM userTbl WHERE name =@name;
```

```sql
EXEC select_by_name '이승기';
EXEC select_by_name '성시경';
EXEC select_by_name '은지원';
```

다음과 같이 사용 할 수 있다.

첫번째 이승기를 검색하는 과정에서만 최적화 및 컴파일을 수행하고 나머지는 메모리(캐시)에 있는것을 사용하게 된다.

## 저장 프로시저의 장점

1. SQL Server의 성능을 향상

- 저장프로시저의 두번째 실행부터는 캐시(메모리)에 있는 것을 가져와서 사용하므로 속도가 빨라진다. 또한, 여러개의 쿼리를 한번에 실행할 수 있다.

2. 유지보수 및 재활용 측면에서 좋다.

- C#, Java등으로 만들어진 응용프로그램에서 직접 SQL문을 호출하지 않고 저장 프로시저의 이름을 호출하도록 설정하여 사용하는 경우가 많은데, 이때 개발자는 수정요건이 발생할때 코드 내 SQL문을 건드리는게 아니라 **SP 파일**만 수정하면 되기 때문에 유지보수 측면에서 유리해진다.( SP 수정으로 조회, 수정, 추가 등의 가벼운 소스 변경 등이 가능)
- 한번 저장 프로시저를 생성해 놓으면, 언제든 실행이 가능하기 때문에 재활용 측면에서 매우 좋다.

3. 보안을 강화할 수 있다.

- 저장 프로시저는 사용자들에게 데이타에 대한 제한적인 접근을 허용케하는 전통적인 수단이다. 사용자별로 테이블에 권한을 주는게 아닌 저장 프로시저에만 접근 권한을 줌으로써 테이블의 모든 정보를 사용자에게 노출하지 않고 **프로시저에서 선택한 정보**만 사용자에게 보여줄 수 있다.

4. 네트워크 부하 줄일 수 있음

- 클라이언트에서 서버로 쿼리의 모든 텍스트가 전송될 경우 네트워크에는 큰 부하가 발생
- 저장 프로시저를 사용하면 저장프로시저의 이름, 매개변수 등 몇글자만 전송하면 되기 때문에 부하를 크게 줄일 수 있다.

## 저장 프로시저의 단점

1. DB 확장 어려움

- 서버의 수를 늘려야할 때, DB의 수를 늘리는 것이 더 어렵다.
- DB 교체는 거의 불가능하다.

2. 데이터 분석의 어려움

- 개발된 프로시저가 여러 곳에서 사용 될 경우 수정했을 때 영향의 분석이 어렵다(별도의 Description 사용).
- 배포, 버전 관리 등에 대한 이력 관리가 힘들다.
- APP에서 SP를 호출하여 사용하는 경우 문제가 생겨도 해당 이슈에 대한 추적이 힘들다(별도의 에러 테이블 사용).

3. 낮은 처리 성능

- 문자, 숫자열 연산에 SP를 사용하면 오히려 c, java보다 느린 성능을 보일 수 있다.

# 질문

1. 어떤 방식으로 저장 프로시저는 보안을 강화하나요?
2. 저장 프로시저가 SQL Server의 성능을 향상시키는 이유는 무엇인가요?

# 참고자료

https://velog.io/@sweet_sumin/%EC%A0%80%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80-Stored-Procedure

https://devkingdom.tistory.com/323
